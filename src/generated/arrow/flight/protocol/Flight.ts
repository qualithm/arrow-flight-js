// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: arrow/flight/protocol/Flight.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire"
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleBidiStreamingCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation
} from "@grpc/grpc-js"
import { Timestamp } from "../../../google/protobuf/timestamp.js"

export const protobufPackage = "arrow.flight.protocol"

/**
 * The result of a cancel operation.
 *
 * This is used by CancelFlightInfoResult.status.
 */
export enum CancelStatus {
  /**
   * CANCEL_STATUS_UNSPECIFIED - The cancellation status is unknown. Servers should avoid using
   * this value (send a NOT_FOUND error if the requested query is
   * not known). Clients can retry the request.
   */
  CANCEL_STATUS_UNSPECIFIED = 0,
  /**
   * CANCEL_STATUS_CANCELLED - The cancellation request is complete. Subsequent requests with
   * the same payload may return CANCELLED or a NOT_FOUND error.
   */
  CANCEL_STATUS_CANCELLED = 1,
  /**
   * CANCEL_STATUS_CANCELLING - The cancellation request is in progress. The client may retry
   * the cancellation request.
   */
  CANCEL_STATUS_CANCELLING = 2,
  /**
   * CANCEL_STATUS_NOT_CANCELLABLE - The query is not cancellable. The client should not retry the
   * cancellation request.
   */
  CANCEL_STATUS_NOT_CANCELLABLE = 3,
  UNRECOGNIZED = -1
}

export function cancelStatusFromJSON(object: any): CancelStatus {
  switch (object) {
    case 0:
    case "CANCEL_STATUS_UNSPECIFIED":
      return CancelStatus.CANCEL_STATUS_UNSPECIFIED
    case 1:
    case "CANCEL_STATUS_CANCELLED":
      return CancelStatus.CANCEL_STATUS_CANCELLED
    case 2:
    case "CANCEL_STATUS_CANCELLING":
      return CancelStatus.CANCEL_STATUS_CANCELLING
    case 3:
    case "CANCEL_STATUS_NOT_CANCELLABLE":
      return CancelStatus.CANCEL_STATUS_NOT_CANCELLABLE
    case -1:
    case "UNRECOGNIZED":
    default:
      return CancelStatus.UNRECOGNIZED
  }
}

export function cancelStatusToJSON(object: CancelStatus): string {
  switch (object) {
    case CancelStatus.CANCEL_STATUS_UNSPECIFIED:
      return "CANCEL_STATUS_UNSPECIFIED"
    case CancelStatus.CANCEL_STATUS_CANCELLED:
      return "CANCEL_STATUS_CANCELLED"
    case CancelStatus.CANCEL_STATUS_CANCELLING:
      return "CANCEL_STATUS_CANCELLING"
    case CancelStatus.CANCEL_STATUS_NOT_CANCELLABLE:
      return "CANCEL_STATUS_NOT_CANCELLABLE"
    case CancelStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED"
  }
}

/** The request that a client provides to a server on handshake. */
export interface HandshakeRequest {
  /** A defined protocol version */
  protocolVersion: number
  /** Arbitrary auth/handshake info. */
  payload: Buffer
}

export interface HandshakeResponse {
  /** A defined protocol version */
  protocolVersion: number
  /** Arbitrary auth/handshake info. */
  payload: Buffer
}

/** A message for doing simple auth. */
export interface BasicAuth {
  username: string
  password: string
}

export interface Empty {}

/**
 * Describes an available action, including both the name used for execution
 * along with a short description of the purpose of the action.
 */
export interface ActionType {
  type: string
  description: string
}

/**
 * A service specific expression that can be used to return a limited set
 * of available Arrow Flight streams.
 */
export interface Criteria {
  expression: Buffer
}

/** An opaque action specific for the service. */
export interface Action {
  type: string
  body: Buffer
}

/** An opaque result returned after executing an action. */
export interface Result {
  body: Buffer
}

/** Wrap the result of a getSchema call */
export interface SchemaResult {
  /**
   * The schema of the dataset in its IPC form:
   *   4 bytes - an optional IPC_CONTINUATION_TOKEN prefix
   *   4 bytes - the byte length of the payload
   *   a flatbuffer Message whose header is the Schema
   */
  schema: Buffer
}

/**
 * The name or tag for a Flight. May be used as a way to retrieve or generate
 * a flight or be used to expose a set of previously defined flights.
 */
export interface FlightDescriptor {
  type: FlightDescriptor_DescriptorType
  /**
   * Opaque value used to express a command. Should only be defined when
   * type = CMD.
   */
  cmd: Buffer
  /**
   * List of strings identifying a particular dataset. Should only be defined
   * when type = PATH.
   */
  path: string[]
}

/** Describes what type of descriptor is defined. */
export enum FlightDescriptor_DescriptorType {
  /** UNKNOWN - Protobuf pattern, not used. */
  UNKNOWN = 0,
  /**
   * PATH - A named path that identifies a dataset. A path is composed of a string
   * or list of strings describing a particular dataset. This is conceptually
   *  similar to a path inside a filesystem.
   */
  PATH = 1,
  /** CMD - An opaque command to generate a dataset. */
  CMD = 2,
  UNRECOGNIZED = -1
}

export function flightDescriptor_DescriptorTypeFromJSON(
  object: any
): FlightDescriptor_DescriptorType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return FlightDescriptor_DescriptorType.UNKNOWN
    case 1:
    case "PATH":
      return FlightDescriptor_DescriptorType.PATH
    case 2:
    case "CMD":
      return FlightDescriptor_DescriptorType.CMD
    case -1:
    case "UNRECOGNIZED":
    default:
      return FlightDescriptor_DescriptorType.UNRECOGNIZED
  }
}

export function flightDescriptor_DescriptorTypeToJSON(
  object: FlightDescriptor_DescriptorType
): string {
  switch (object) {
    case FlightDescriptor_DescriptorType.UNKNOWN:
      return "UNKNOWN"
    case FlightDescriptor_DescriptorType.PATH:
      return "PATH"
    case FlightDescriptor_DescriptorType.CMD:
      return "CMD"
    case FlightDescriptor_DescriptorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED"
  }
}

/**
 * The access coordinates for retrieval of a dataset. With a FlightInfo, a
 * consumer is able to determine how to retrieve a dataset.
 */
export interface FlightInfo {
  /**
   * The schema of the dataset in its IPC form:
   *   4 bytes - an optional IPC_CONTINUATION_TOKEN prefix
   *   4 bytes - the byte length of the payload
   *   a flatbuffer Message whose header is the Schema
   */
  schema: Buffer
  /** The descriptor associated with this info. */
  flightDescriptor: FlightDescriptor | undefined
  /**
   * A list of endpoints associated with the flight. To consume the
   * whole flight, all endpoints (and hence all Tickets) must be
   * consumed. Endpoints can be consumed in any order.
   *
   * In other words, an application can use multiple endpoints to
   * represent partitioned data.
   *
   * If the returned data has an ordering, an application can use
   * "FlightInfo.ordered = true" or should return all data in a
   * single endpoint. Otherwise, there is no ordering defined on
   * endpoints or the data within.
   *
   * A client can read ordered data by reading data from returned
   * endpoints, in order, from front to back.
   *
   * Note that a client may ignore "FlightInfo.ordered = true". If an
   * ordering is important for an application, an application must
   * choose one of them:
   *
   * * An application requires that all clients must read data in
   *   returned endpoints order.
   * * An application must return all data in a single endpoint.
   */
  endpoint: FlightEndpoint[]
  /** Set these to -1 if unknown. */
  totalRecords: number
  totalBytes: number
  /** FlightEndpoints are in the same order as the data. */
  ordered: boolean
  /**
   * Application-defined metadata.
   *
   * There is no inherent or required relationship between this
   * and the app_metadata fields in the FlightEndpoints or resulting
   * FlightData messages. Since this metadata is application-defined,
   * a given application could define there to be a relationship,
   * but there is none required by the spec.
   */
  appMetadata: Buffer
}

/** The information to process a long-running query. */
export interface PollInfo {
  /**
   * The currently available results.
   *
   * If "flight_descriptor" is not specified, the query is complete
   * and "info" specifies all results. Otherwise, "info" contains
   * partial query results.
   *
   * Note that each PollInfo response contains a complete
   * FlightInfo (not just the delta between the previous and current
   * FlightInfo).
   *
   * Subsequent PollInfo responses may only append new endpoints to
   * info.
   *
   * Clients can begin fetching results via DoGet(Ticket) with the
   * ticket in the info before the query is
   * completed. FlightInfo.ordered is also valid.
   */
  info: FlightInfo | undefined
  /**
   * The descriptor the client should use on the next try.
   * If unset, the query is complete.
   */
  flightDescriptor: FlightDescriptor | undefined
  /**
   * Query progress. If known, must be in [0.0, 1.0] but need not be
   * monotonic or nondecreasing. If unknown, do not set.
   */
  progress?: number | undefined
  /**
   * Expiration time for this request. After this passes, the server
   * might not accept the retry descriptor anymore (and the query may
   * be cancelled). This may be updated on a call to PollFlightInfo.
   */
  expirationTime: Date | undefined
}

/**
 * The request of the CancelFlightInfo action.
 *
 * The request should be stored in Action.body.
 */
export interface CancelFlightInfoRequest {
  info: FlightInfo | undefined
}

/**
 * The result of the CancelFlightInfo action.
 *
 * The result should be stored in Result.body.
 */
export interface CancelFlightInfoResult {
  status: CancelStatus
}

/**
 * An opaque identifier that the service can use to retrieve a particular
 * portion of a stream.
 *
 * Tickets are meant to be single use. It is an error/application-defined
 * behavior to reuse a ticket.
 */
export interface Ticket {
  ticket: Buffer
}

/**
 * A location to retrieve a particular stream from. This URI should be one of
 * the following:
 *  - An empty string or the string 'arrow-flight-reuse-connection://?':
 *    indicating that the ticket can be redeemed on the service where the
 *    ticket was generated via a DoGet request.
 *  - A valid grpc URI (grpc://, grpc+tls://, grpc+unix://, etc.):
 *    indicating that the ticket can be redeemed on the service at the given
 *    URI via a DoGet request.
 *  - A valid HTTP URI (http://, https://, etc.):
 *    indicating that the client should perform a GET request against the
 *    given URI to retrieve the stream. The ticket should be empty
 *    in this case and should be ignored by the client. Cloud object storage
 *    can be utilized by presigned URLs or mediating the auth separately and
 *    returning the full URL (e.g. https://amzn-s3-demo-bucket.s3.us-west-2.amazonaws.com/...).
 *
 * We allow non-Flight URIs for the purpose of allowing Flight services to indicate that
 * results can be downloaded in formats other than Arrow (such as Parquet) or to allow
 * direct fetching of results from a URI to reduce excess copying and data movement.
 * In these cases, the following conventions should be followed by servers and clients:
 *
 *  - Unless otherwise specified by the 'Content-Type' header of the response,
 *    a client should assume the response is using the Arrow IPC Streaming format.
 *    Usage of an IANA media type like 'application/octet-stream' should be assumed to
 *    be using the Arrow IPC Streaming format.
 *  - The server may allow the client to choose a specific response format by
 *    specifying an 'Accept' header in the request, such as 'application/vnd.apache.parquet'
 *    or 'application/vnd.apache.arrow.stream'. If multiple types are requested and
 *    supported by the server, the choice of which to use is server-specific. If
 *    none of the requested content-types are supported, the server may respond with
 *    either 406 (Not Acceptable) or 415 (Unsupported Media Type), or successfully
 *    respond with a different format that it does support along with the correct
 *    'Content-Type' header.
 *
 * Note: new schemes may be proposed in the future to allow for more flexibility based
 * on community requests.
 */
export interface Location {
  uri: string
}

/** A particular stream or split associated with a flight. */
export interface FlightEndpoint {
  /** Token used to retrieve this stream. */
  ticket: Ticket | undefined
  /**
   * A list of URIs where this ticket can be redeemed via DoGet().
   *
   * If the list is empty, the expectation is that the ticket can only
   * be redeemed on the current service where the ticket was
   * generated.
   *
   * If the list is not empty, the expectation is that the ticket can be
   * redeemed at any of the locations, and that the data returned will be
   * equivalent. In this case, the ticket may only be redeemed at one of the
   * given locations, and not (necessarily) on the current service. If one
   * of the given locations is "arrow-flight-reuse-connection://?", the
   * client may redeem the ticket on the service where the ticket was
   * generated (i.e., the same as above), in addition to the other
   * locations. (This URI was chosen to maximize compatibility, as 'scheme:'
   * or 'scheme://' are not accepted by Java's java.net.URI.)
   *
   * In other words, an application can use multiple locations to
   * represent redundant and/or load balanced services.
   */
  location: Location[]
  /**
   * Expiration time of this stream. If present, clients may assume
   * they can retry DoGet requests. Otherwise, it is
   * application-defined whether DoGet requests may be retried.
   */
  expirationTime: Date | undefined
  /**
   * Application-defined metadata.
   *
   * There is no inherent or required relationship between this
   * and the app_metadata fields in the FlightInfo or resulting
   * FlightData messages. Since this metadata is application-defined,
   * a given application could define there to be a relationship,
   * but there is none required by the spec.
   */
  appMetadata: Buffer
}

/**
 * The request of the RenewFlightEndpoint action.
 *
 * The request should be stored in Action.body.
 */
export interface RenewFlightEndpointRequest {
  endpoint: FlightEndpoint | undefined
}

/** A batch of Arrow data as part of a stream of batches. */
export interface FlightData {
  /**
   * The descriptor of the data. This is only relevant when a client is
   * starting a new DoPut stream.
   */
  flightDescriptor: FlightDescriptor | undefined
  /** Header for message data as described in Message.fbs::Message. */
  dataHeader: Buffer
  /** Application-defined metadata. */
  appMetadata: Buffer
  /**
   * The actual batch of Arrow data. Preferably handled with minimal-copies
   * coming last in the definition to help with sidecar patterns (it is
   * expected that some implementations will fetch this field off the wire
   * with specialized code to avoid extra memory copies).
   */
  dataBody: Buffer
}

/** The response message associated with the submission of a DoPut. */
export interface PutResult {
  appMetadata: Buffer
}

/**
 * EXPERIMENTAL: Union of possible value types for a Session Option to be set to.
 *
 * By convention, an attempt to set a valueless SessionOptionValue should
 * attempt to unset or clear the named option value on the server.
 */
export interface SessionOptionValue {
  stringValue?: string | undefined
  boolValue?: boolean | undefined
  int64Value?: number | undefined
  doubleValue?: number | undefined
  stringListValue?: SessionOptionValue_StringListValue | undefined
}

export interface SessionOptionValue_StringListValue {
  values: string[]
}

/**
 * EXPERIMENTAL: A request to set session options for an existing or new (implicit)
 * server session.
 *
 * Sessions are persisted and referenced via a transport-level state management, typically
 * RFC 6265 HTTP cookies when using an HTTP transport.  The suggested cookie name or state
 * context key is 'arrow_flight_session_id', although implementations may freely choose their
 * own name.
 *
 * Session creation (if one does not already exist) is implied by this RPC request, however
 * server implementations may choose to initiate a session that also contains client-provided
 * session options at any other time, e.g. on authentication, or when any other call is made
 * and the server wishes to use a session to persist any state (or lack thereof).
 */
export interface SetSessionOptionsRequest {
  sessionOptions: { [key: string]: SessionOptionValue }
}

export interface SetSessionOptionsRequest_SessionOptionsEntry {
  key: string
  value: SessionOptionValue | undefined
}

/**
 * EXPERIMENTAL: The results (individually) of setting a set of session options.
 *
 * Option names should only be present in the response if they were not successfully
 * set on the server; that is, a response without an Error for a name provided in the
 * SetSessionOptionsRequest implies that the named option value was set successfully.
 */
export interface SetSessionOptionsResult {
  errors: { [key: string]: SetSessionOptionsResult_Error }
}

export enum SetSessionOptionsResult_ErrorValue {
  /**
   * UNSPECIFIED - Protobuf deserialization fallback value: The status is unknown or unrecognized.
   * Servers should avoid using this value. The request may be retried by the client.
   */
  UNSPECIFIED = 0,
  /** INVALID_NAME - The given session option name is invalid. */
  INVALID_NAME = 1,
  /** INVALID_VALUE - The session option value or type is invalid. */
  INVALID_VALUE = 2,
  /** ERROR - The session option cannot be set. */
  ERROR = 3,
  UNRECOGNIZED = -1
}

export function setSessionOptionsResult_ErrorValueFromJSON(
  object: any
): SetSessionOptionsResult_ErrorValue {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return SetSessionOptionsResult_ErrorValue.UNSPECIFIED
    case 1:
    case "INVALID_NAME":
      return SetSessionOptionsResult_ErrorValue.INVALID_NAME
    case 2:
    case "INVALID_VALUE":
      return SetSessionOptionsResult_ErrorValue.INVALID_VALUE
    case 3:
    case "ERROR":
      return SetSessionOptionsResult_ErrorValue.ERROR
    case -1:
    case "UNRECOGNIZED":
    default:
      return SetSessionOptionsResult_ErrorValue.UNRECOGNIZED
  }
}

export function setSessionOptionsResult_ErrorValueToJSON(
  object: SetSessionOptionsResult_ErrorValue
): string {
  switch (object) {
    case SetSessionOptionsResult_ErrorValue.UNSPECIFIED:
      return "UNSPECIFIED"
    case SetSessionOptionsResult_ErrorValue.INVALID_NAME:
      return "INVALID_NAME"
    case SetSessionOptionsResult_ErrorValue.INVALID_VALUE:
      return "INVALID_VALUE"
    case SetSessionOptionsResult_ErrorValue.ERROR:
      return "ERROR"
    case SetSessionOptionsResult_ErrorValue.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED"
  }
}

export interface SetSessionOptionsResult_Error {
  value: SetSessionOptionsResult_ErrorValue
}

export interface SetSessionOptionsResult_ErrorsEntry {
  key: string
  value: SetSessionOptionsResult_Error | undefined
}

/**
 * EXPERIMENTAL: A request to access the session options for the current server session.
 *
 * The existing session is referenced via a cookie header or similar (see
 * SetSessionOptionsRequest above); it is an error to make this request with a missing,
 * invalid, or expired session cookie header or other implementation-defined session
 * reference token.
 */
export interface GetSessionOptionsRequest {}

/** EXPERIMENTAL: The result containing the current server session options. */
export interface GetSessionOptionsResult {
  sessionOptions: { [key: string]: SessionOptionValue }
}

export interface GetSessionOptionsResult_SessionOptionsEntry {
  key: string
  value: SessionOptionValue | undefined
}

/**
 * Request message for the "Close Session" action.
 *
 * The existing session is referenced via a cookie header.
 */
export interface CloseSessionRequest {}

/** The result of closing a session. */
export interface CloseSessionResult {
  status: CloseSessionResult_Status
}

export enum CloseSessionResult_Status {
  /**
   * UNSPECIFIED - Protobuf deserialization fallback value: The session close status is unknown or
   * not recognized. Servers should avoid using this value (send a NOT_FOUND error if
   * the requested session is not known or expired). Clients can retry the request.
   */
  UNSPECIFIED = 0,
  /**
   * CLOSED - The session close request is complete. Subsequent requests with
   * the same session produce a NOT_FOUND error.
   */
  CLOSED = 1,
  /**
   * CLOSING - The session close request is in progress. The client may retry
   * the close request.
   */
  CLOSING = 2,
  /**
   * NOT_CLOSEABLE - The session is not closeable. The client should not retry the
   * close request.
   */
  NOT_CLOSEABLE = 3,
  UNRECOGNIZED = -1
}

export function closeSessionResult_StatusFromJSON(object: any): CloseSessionResult_Status {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return CloseSessionResult_Status.UNSPECIFIED
    case 1:
    case "CLOSED":
      return CloseSessionResult_Status.CLOSED
    case 2:
    case "CLOSING":
      return CloseSessionResult_Status.CLOSING
    case 3:
    case "NOT_CLOSEABLE":
      return CloseSessionResult_Status.NOT_CLOSEABLE
    case -1:
    case "UNRECOGNIZED":
    default:
      return CloseSessionResult_Status.UNRECOGNIZED
  }
}

export function closeSessionResult_StatusToJSON(object: CloseSessionResult_Status): string {
  switch (object) {
    case CloseSessionResult_Status.UNSPECIFIED:
      return "UNSPECIFIED"
    case CloseSessionResult_Status.CLOSED:
      return "CLOSED"
    case CloseSessionResult_Status.CLOSING:
      return "CLOSING"
    case CloseSessionResult_Status.NOT_CLOSEABLE:
      return "NOT_CLOSEABLE"
    case CloseSessionResult_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED"
  }
}

function createBaseHandshakeRequest(): HandshakeRequest {
  return { protocolVersion: 0, payload: Buffer.alloc(0) }
}

export const HandshakeRequest: MessageFns<HandshakeRequest> = {
  encode(message: HandshakeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocolVersion !== 0) {
      writer.uint32(8).uint64(message.protocolVersion)
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandshakeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseHandshakeRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break
          }

          message.protocolVersion = longToNumber(reader.uint64())
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.payload = Buffer.from(reader.bytes())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): HandshakeRequest {
    return {
      protocolVersion: isSet(object.protocolVersion)
        ? globalThis.Number(object.protocolVersion)
        : 0,
      payload: isSet(object.payload)
        ? Buffer.from(bytesFromBase64(object.payload))
        : Buffer.alloc(0)
    }
  },

  toJSON(message: HandshakeRequest): unknown {
    const obj: any = {}
    if (message.protocolVersion !== 0) {
      obj.protocolVersion = Math.round(message.protocolVersion)
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload)
    }
    return obj
  },

  create(base?: DeepPartial<HandshakeRequest>): HandshakeRequest {
    return HandshakeRequest.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<HandshakeRequest>): HandshakeRequest {
    const message = createBaseHandshakeRequest()
    message.protocolVersion = object.protocolVersion ?? 0
    message.payload = object.payload ?? Buffer.alloc(0)
    return message
  }
}

function createBaseHandshakeResponse(): HandshakeResponse {
  return { protocolVersion: 0, payload: Buffer.alloc(0) }
}

export const HandshakeResponse: MessageFns<HandshakeResponse> = {
  encode(message: HandshakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocolVersion !== 0) {
      writer.uint32(8).uint64(message.protocolVersion)
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandshakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseHandshakeResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break
          }

          message.protocolVersion = longToNumber(reader.uint64())
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.payload = Buffer.from(reader.bytes())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): HandshakeResponse {
    return {
      protocolVersion: isSet(object.protocolVersion)
        ? globalThis.Number(object.protocolVersion)
        : 0,
      payload: isSet(object.payload)
        ? Buffer.from(bytesFromBase64(object.payload))
        : Buffer.alloc(0)
    }
  },

  toJSON(message: HandshakeResponse): unknown {
    const obj: any = {}
    if (message.protocolVersion !== 0) {
      obj.protocolVersion = Math.round(message.protocolVersion)
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload)
    }
    return obj
  },

  create(base?: DeepPartial<HandshakeResponse>): HandshakeResponse {
    return HandshakeResponse.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<HandshakeResponse>): HandshakeResponse {
    const message = createBaseHandshakeResponse()
    message.protocolVersion = object.protocolVersion ?? 0
    message.payload = object.payload ?? Buffer.alloc(0)
    return message
  }
}

function createBaseBasicAuth(): BasicAuth {
  return { username: "", password: "" }
}

export const BasicAuth: MessageFns<BasicAuth> = {
  encode(message: BasicAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(18).string(message.username)
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasicAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseBasicAuth()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break
          }

          message.username = reader.string()
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.password = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): BasicAuth {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : ""
    }
  },

  toJSON(message: BasicAuth): unknown {
    const obj: any = {}
    if (message.username !== "") {
      obj.username = message.username
    }
    if (message.password !== "") {
      obj.password = message.password
    }
    return obj
  },

  create(base?: DeepPartial<BasicAuth>): BasicAuth {
    return BasicAuth.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<BasicAuth>): BasicAuth {
    const message = createBaseBasicAuth()
    message.username = object.username ?? ""
    message.password = object.password ?? ""
    return message
  }
}

function createBaseEmpty(): Empty {
  return {}
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseEmpty()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(_: any): Empty {
    return {}
  },

  toJSON(_: Empty): unknown {
    const obj: any = {}
    return obj
  },

  create(base?: DeepPartial<Empty>): Empty {
    return Empty.fromPartial(base ?? {})
  },
  fromPartial(_: DeepPartial<Empty>): Empty {
    const message = createBaseEmpty()
    return message
  }
}

function createBaseActionType(): ActionType {
  return { type: "", description: "" }
}

export const ActionType: MessageFns<ActionType> = {
  encode(message: ActionType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type)
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseActionType()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.type = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.description = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): ActionType {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : ""
    }
  },

  toJSON(message: ActionType): unknown {
    const obj: any = {}
    if (message.type !== "") {
      obj.type = message.type
    }
    if (message.description !== "") {
      obj.description = message.description
    }
    return obj
  },

  create(base?: DeepPartial<ActionType>): ActionType {
    return ActionType.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<ActionType>): ActionType {
    const message = createBaseActionType()
    message.type = object.type ?? ""
    message.description = object.description ?? ""
    return message
  }
}

function createBaseCriteria(): Criteria {
  return { expression: Buffer.alloc(0) }
}

export const Criteria: MessageFns<Criteria> = {
  encode(message: Criteria, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expression.length !== 0) {
      writer.uint32(10).bytes(message.expression)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Criteria {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseCriteria()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.expression = Buffer.from(reader.bytes())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Criteria {
    return {
      expression: isSet(object.expression)
        ? Buffer.from(bytesFromBase64(object.expression))
        : Buffer.alloc(0)
    }
  },

  toJSON(message: Criteria): unknown {
    const obj: any = {}
    if (message.expression.length !== 0) {
      obj.expression = base64FromBytes(message.expression)
    }
    return obj
  },

  create(base?: DeepPartial<Criteria>): Criteria {
    return Criteria.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<Criteria>): Criteria {
    const message = createBaseCriteria()
    message.expression = object.expression ?? Buffer.alloc(0)
    return message
  }
}

function createBaseAction(): Action {
  return { type: "", body: Buffer.alloc(0) }
}

export const Action: MessageFns<Action> = {
  encode(message: Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type)
    }
    if (message.body.length !== 0) {
      writer.uint32(18).bytes(message.body)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseAction()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.type = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.body = Buffer.from(reader.bytes())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Action {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      body: isSet(object.body) ? Buffer.from(bytesFromBase64(object.body)) : Buffer.alloc(0)
    }
  },

  toJSON(message: Action): unknown {
    const obj: any = {}
    if (message.type !== "") {
      obj.type = message.type
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body)
    }
    return obj
  },

  create(base?: DeepPartial<Action>): Action {
    return Action.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<Action>): Action {
    const message = createBaseAction()
    message.type = object.type ?? ""
    message.body = object.body ?? Buffer.alloc(0)
    return message
  }
}

function createBaseResult(): Result {
  return { body: Buffer.alloc(0) }
}

export const Result: MessageFns<Result> = {
  encode(message: Result, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.body.length !== 0) {
      writer.uint32(10).bytes(message.body)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Result {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseResult()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.body = Buffer.from(reader.bytes())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Result {
    return {
      body: isSet(object.body) ? Buffer.from(bytesFromBase64(object.body)) : Buffer.alloc(0)
    }
  },

  toJSON(message: Result): unknown {
    const obj: any = {}
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body)
    }
    return obj
  },

  create(base?: DeepPartial<Result>): Result {
    return Result.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<Result>): Result {
    const message = createBaseResult()
    message.body = object.body ?? Buffer.alloc(0)
    return message
  }
}

function createBaseSchemaResult(): SchemaResult {
  return { schema: Buffer.alloc(0) }
}

export const SchemaResult: MessageFns<SchemaResult> = {
  encode(message: SchemaResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schema.length !== 0) {
      writer.uint32(10).bytes(message.schema)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchemaResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseSchemaResult()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.schema = Buffer.from(reader.bytes())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): SchemaResult {
    return {
      schema: isSet(object.schema) ? Buffer.from(bytesFromBase64(object.schema)) : Buffer.alloc(0)
    }
  },

  toJSON(message: SchemaResult): unknown {
    const obj: any = {}
    if (message.schema.length !== 0) {
      obj.schema = base64FromBytes(message.schema)
    }
    return obj
  },

  create(base?: DeepPartial<SchemaResult>): SchemaResult {
    return SchemaResult.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<SchemaResult>): SchemaResult {
    const message = createBaseSchemaResult()
    message.schema = object.schema ?? Buffer.alloc(0)
    return message
  }
}

function createBaseFlightDescriptor(): FlightDescriptor {
  return { type: 0, cmd: Buffer.alloc(0), path: [] }
}

export const FlightDescriptor: MessageFns<FlightDescriptor> = {
  encode(message: FlightDescriptor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type)
    }
    if (message.cmd.length !== 0) {
      writer.uint32(18).bytes(message.cmd)
    }
    for (const v of message.path) {
      writer.uint32(26).string(v!)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlightDescriptor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseFlightDescriptor()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break
          }

          message.type = reader.int32() as any
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.cmd = Buffer.from(reader.bytes())
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.path.push(reader.string())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): FlightDescriptor {
    return {
      type: isSet(object.type) ? flightDescriptor_DescriptorTypeFromJSON(object.type) : 0,
      cmd: isSet(object.cmd) ? Buffer.from(bytesFromBase64(object.cmd)) : Buffer.alloc(0),
      path: globalThis.Array.isArray(object?.path)
        ? object.path.map((e: any) => globalThis.String(e))
        : []
    }
  },

  toJSON(message: FlightDescriptor): unknown {
    const obj: any = {}
    if (message.type !== 0) {
      obj.type = flightDescriptor_DescriptorTypeToJSON(message.type)
    }
    if (message.cmd.length !== 0) {
      obj.cmd = base64FromBytes(message.cmd)
    }
    if (message.path?.length) {
      obj.path = message.path
    }
    return obj
  },

  create(base?: DeepPartial<FlightDescriptor>): FlightDescriptor {
    return FlightDescriptor.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<FlightDescriptor>): FlightDescriptor {
    const message = createBaseFlightDescriptor()
    message.type = object.type ?? 0
    message.cmd = object.cmd ?? Buffer.alloc(0)
    message.path = object.path?.map((e) => e) || []
    return message
  }
}

function createBaseFlightInfo(): FlightInfo {
  return {
    schema: Buffer.alloc(0),
    flightDescriptor: undefined,
    endpoint: [],
    totalRecords: 0,
    totalBytes: 0,
    ordered: false,
    appMetadata: Buffer.alloc(0)
  }
}

export const FlightInfo: MessageFns<FlightInfo> = {
  encode(message: FlightInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schema.length !== 0) {
      writer.uint32(10).bytes(message.schema)
    }
    if (message.flightDescriptor !== undefined) {
      FlightDescriptor.encode(message.flightDescriptor, writer.uint32(18).fork()).join()
    }
    for (const v of message.endpoint) {
      FlightEndpoint.encode(v!, writer.uint32(26).fork()).join()
    }
    if (message.totalRecords !== 0) {
      writer.uint32(32).int64(message.totalRecords)
    }
    if (message.totalBytes !== 0) {
      writer.uint32(40).int64(message.totalBytes)
    }
    if (message.ordered !== false) {
      writer.uint32(48).bool(message.ordered)
    }
    if (message.appMetadata.length !== 0) {
      writer.uint32(58).bytes(message.appMetadata)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlightInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseFlightInfo()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.schema = Buffer.from(reader.bytes())
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.flightDescriptor = FlightDescriptor.decode(reader, reader.uint32())
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.endpoint.push(FlightEndpoint.decode(reader, reader.uint32()))
          continue
        }
        case 4: {
          if (tag !== 32) {
            break
          }

          message.totalRecords = longToNumber(reader.int64())
          continue
        }
        case 5: {
          if (tag !== 40) {
            break
          }

          message.totalBytes = longToNumber(reader.int64())
          continue
        }
        case 6: {
          if (tag !== 48) {
            break
          }

          message.ordered = reader.bool()
          continue
        }
        case 7: {
          if (tag !== 58) {
            break
          }

          message.appMetadata = Buffer.from(reader.bytes())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): FlightInfo {
    return {
      schema: isSet(object.schema) ? Buffer.from(bytesFromBase64(object.schema)) : Buffer.alloc(0),
      flightDescriptor: isSet(object.flightDescriptor)
        ? FlightDescriptor.fromJSON(object.flightDescriptor)
        : undefined,
      endpoint: globalThis.Array.isArray(object?.endpoint)
        ? object.endpoint.map((e: any) => FlightEndpoint.fromJSON(e))
        : [],
      totalRecords: isSet(object.totalRecords) ? globalThis.Number(object.totalRecords) : 0,
      totalBytes: isSet(object.totalBytes) ? globalThis.Number(object.totalBytes) : 0,
      ordered: isSet(object.ordered) ? globalThis.Boolean(object.ordered) : false,
      appMetadata: isSet(object.appMetadata)
        ? Buffer.from(bytesFromBase64(object.appMetadata))
        : Buffer.alloc(0)
    }
  },

  toJSON(message: FlightInfo): unknown {
    const obj: any = {}
    if (message.schema.length !== 0) {
      obj.schema = base64FromBytes(message.schema)
    }
    if (message.flightDescriptor !== undefined) {
      obj.flightDescriptor = FlightDescriptor.toJSON(message.flightDescriptor)
    }
    if (message.endpoint?.length) {
      obj.endpoint = message.endpoint.map((e) => FlightEndpoint.toJSON(e))
    }
    if (message.totalRecords !== 0) {
      obj.totalRecords = Math.round(message.totalRecords)
    }
    if (message.totalBytes !== 0) {
      obj.totalBytes = Math.round(message.totalBytes)
    }
    if (message.ordered !== false) {
      obj.ordered = message.ordered
    }
    if (message.appMetadata.length !== 0) {
      obj.appMetadata = base64FromBytes(message.appMetadata)
    }
    return obj
  },

  create(base?: DeepPartial<FlightInfo>): FlightInfo {
    return FlightInfo.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<FlightInfo>): FlightInfo {
    const message = createBaseFlightInfo()
    message.schema = object.schema ?? Buffer.alloc(0)
    message.flightDescriptor =
      object.flightDescriptor !== undefined && object.flightDescriptor !== null
        ? FlightDescriptor.fromPartial(object.flightDescriptor)
        : undefined
    message.endpoint = object.endpoint?.map((e) => FlightEndpoint.fromPartial(e)) || []
    message.totalRecords = object.totalRecords ?? 0
    message.totalBytes = object.totalBytes ?? 0
    message.ordered = object.ordered ?? false
    message.appMetadata = object.appMetadata ?? Buffer.alloc(0)
    return message
  }
}

function createBasePollInfo(): PollInfo {
  return {
    info: undefined,
    flightDescriptor: undefined,
    progress: undefined,
    expirationTime: undefined
  }
}

export const PollInfo: MessageFns<PollInfo> = {
  encode(message: PollInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.info !== undefined) {
      FlightInfo.encode(message.info, writer.uint32(10).fork()).join()
    }
    if (message.flightDescriptor !== undefined) {
      FlightDescriptor.encode(message.flightDescriptor, writer.uint32(18).fork()).join()
    }
    if (message.progress !== undefined) {
      writer.uint32(25).double(message.progress)
    }
    if (message.expirationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expirationTime), writer.uint32(34).fork()).join()
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PollInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBasePollInfo()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.info = FlightInfo.decode(reader, reader.uint32())
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.flightDescriptor = FlightDescriptor.decode(reader, reader.uint32())
          continue
        }
        case 3: {
          if (tag !== 25) {
            break
          }

          message.progress = reader.double()
          continue
        }
        case 4: {
          if (tag !== 34) {
            break
          }

          message.expirationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()))
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): PollInfo {
    return {
      info: isSet(object.info) ? FlightInfo.fromJSON(object.info) : undefined,
      flightDescriptor: isSet(object.flightDescriptor)
        ? FlightDescriptor.fromJSON(object.flightDescriptor)
        : undefined,
      progress: isSet(object.progress) ? globalThis.Number(object.progress) : undefined,
      expirationTime: isSet(object.expirationTime)
        ? fromJsonTimestamp(object.expirationTime)
        : undefined
    }
  },

  toJSON(message: PollInfo): unknown {
    const obj: any = {}
    if (message.info !== undefined) {
      obj.info = FlightInfo.toJSON(message.info)
    }
    if (message.flightDescriptor !== undefined) {
      obj.flightDescriptor = FlightDescriptor.toJSON(message.flightDescriptor)
    }
    if (message.progress !== undefined) {
      obj.progress = message.progress
    }
    if (message.expirationTime !== undefined) {
      obj.expirationTime = message.expirationTime.toISOString()
    }
    return obj
  },

  create(base?: DeepPartial<PollInfo>): PollInfo {
    return PollInfo.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<PollInfo>): PollInfo {
    const message = createBasePollInfo()
    message.info =
      object.info !== undefined && object.info !== null
        ? FlightInfo.fromPartial(object.info)
        : undefined
    message.flightDescriptor =
      object.flightDescriptor !== undefined && object.flightDescriptor !== null
        ? FlightDescriptor.fromPartial(object.flightDescriptor)
        : undefined
    message.progress = object.progress ?? undefined
    message.expirationTime = object.expirationTime ?? undefined
    return message
  }
}

function createBaseCancelFlightInfoRequest(): CancelFlightInfoRequest {
  return { info: undefined }
}

export const CancelFlightInfoRequest: MessageFns<CancelFlightInfoRequest> = {
  encode(
    message: CancelFlightInfoRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.info !== undefined) {
      FlightInfo.encode(message.info, writer.uint32(10).fork()).join()
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelFlightInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseCancelFlightInfoRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.info = FlightInfo.decode(reader, reader.uint32())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): CancelFlightInfoRequest {
    return { info: isSet(object.info) ? FlightInfo.fromJSON(object.info) : undefined }
  },

  toJSON(message: CancelFlightInfoRequest): unknown {
    const obj: any = {}
    if (message.info !== undefined) {
      obj.info = FlightInfo.toJSON(message.info)
    }
    return obj
  },

  create(base?: DeepPartial<CancelFlightInfoRequest>): CancelFlightInfoRequest {
    return CancelFlightInfoRequest.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<CancelFlightInfoRequest>): CancelFlightInfoRequest {
    const message = createBaseCancelFlightInfoRequest()
    message.info =
      object.info !== undefined && object.info !== null
        ? FlightInfo.fromPartial(object.info)
        : undefined
    return message
  }
}

function createBaseCancelFlightInfoResult(): CancelFlightInfoResult {
  return { status: 0 }
}

export const CancelFlightInfoResult: MessageFns<CancelFlightInfoResult> = {
  encode(message: CancelFlightInfoResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelFlightInfoResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseCancelFlightInfoResult()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break
          }

          message.status = reader.int32() as any
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): CancelFlightInfoResult {
    return { status: isSet(object.status) ? cancelStatusFromJSON(object.status) : 0 }
  },

  toJSON(message: CancelFlightInfoResult): unknown {
    const obj: any = {}
    if (message.status !== 0) {
      obj.status = cancelStatusToJSON(message.status)
    }
    return obj
  },

  create(base?: DeepPartial<CancelFlightInfoResult>): CancelFlightInfoResult {
    return CancelFlightInfoResult.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<CancelFlightInfoResult>): CancelFlightInfoResult {
    const message = createBaseCancelFlightInfoResult()
    message.status = object.status ?? 0
    return message
  }
}

function createBaseTicket(): Ticket {
  return { ticket: Buffer.alloc(0) }
}

export const Ticket: MessageFns<Ticket> = {
  encode(message: Ticket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ticket.length !== 0) {
      writer.uint32(10).bytes(message.ticket)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ticket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseTicket()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.ticket = Buffer.from(reader.bytes())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Ticket {
    return {
      ticket: isSet(object.ticket) ? Buffer.from(bytesFromBase64(object.ticket)) : Buffer.alloc(0)
    }
  },

  toJSON(message: Ticket): unknown {
    const obj: any = {}
    if (message.ticket.length !== 0) {
      obj.ticket = base64FromBytes(message.ticket)
    }
    return obj
  },

  create(base?: DeepPartial<Ticket>): Ticket {
    return Ticket.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<Ticket>): Ticket {
    const message = createBaseTicket()
    message.ticket = object.ticket ?? Buffer.alloc(0)
    return message
  }
}

function createBaseLocation(): Location {
  return { uri: "" }
}

export const Location: MessageFns<Location> = {
  encode(message: Location, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Location {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseLocation()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.uri = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Location {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" }
  },

  toJSON(message: Location): unknown {
    const obj: any = {}
    if (message.uri !== "") {
      obj.uri = message.uri
    }
    return obj
  },

  create(base?: DeepPartial<Location>): Location {
    return Location.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<Location>): Location {
    const message = createBaseLocation()
    message.uri = object.uri ?? ""
    return message
  }
}

function createBaseFlightEndpoint(): FlightEndpoint {
  return {
    ticket: undefined,
    location: [],
    expirationTime: undefined,
    appMetadata: Buffer.alloc(0)
  }
}

export const FlightEndpoint: MessageFns<FlightEndpoint> = {
  encode(message: FlightEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ticket !== undefined) {
      Ticket.encode(message.ticket, writer.uint32(10).fork()).join()
    }
    for (const v of message.location) {
      Location.encode(v!, writer.uint32(18).fork()).join()
    }
    if (message.expirationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expirationTime), writer.uint32(26).fork()).join()
    }
    if (message.appMetadata.length !== 0) {
      writer.uint32(34).bytes(message.appMetadata)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlightEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseFlightEndpoint()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.ticket = Ticket.decode(reader, reader.uint32())
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.location.push(Location.decode(reader, reader.uint32()))
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.expirationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()))
          continue
        }
        case 4: {
          if (tag !== 34) {
            break
          }

          message.appMetadata = Buffer.from(reader.bytes())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): FlightEndpoint {
    return {
      ticket: isSet(object.ticket) ? Ticket.fromJSON(object.ticket) : undefined,
      location: globalThis.Array.isArray(object?.location)
        ? object.location.map((e: any) => Location.fromJSON(e))
        : [],
      expirationTime: isSet(object.expirationTime)
        ? fromJsonTimestamp(object.expirationTime)
        : undefined,
      appMetadata: isSet(object.appMetadata)
        ? Buffer.from(bytesFromBase64(object.appMetadata))
        : Buffer.alloc(0)
    }
  },

  toJSON(message: FlightEndpoint): unknown {
    const obj: any = {}
    if (message.ticket !== undefined) {
      obj.ticket = Ticket.toJSON(message.ticket)
    }
    if (message.location?.length) {
      obj.location = message.location.map((e) => Location.toJSON(e))
    }
    if (message.expirationTime !== undefined) {
      obj.expirationTime = message.expirationTime.toISOString()
    }
    if (message.appMetadata.length !== 0) {
      obj.appMetadata = base64FromBytes(message.appMetadata)
    }
    return obj
  },

  create(base?: DeepPartial<FlightEndpoint>): FlightEndpoint {
    return FlightEndpoint.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<FlightEndpoint>): FlightEndpoint {
    const message = createBaseFlightEndpoint()
    message.ticket =
      object.ticket !== undefined && object.ticket !== null
        ? Ticket.fromPartial(object.ticket)
        : undefined
    message.location = object.location?.map((e) => Location.fromPartial(e)) || []
    message.expirationTime = object.expirationTime ?? undefined
    message.appMetadata = object.appMetadata ?? Buffer.alloc(0)
    return message
  }
}

function createBaseRenewFlightEndpointRequest(): RenewFlightEndpointRequest {
  return { endpoint: undefined }
}

export const RenewFlightEndpointRequest: MessageFns<RenewFlightEndpointRequest> = {
  encode(
    message: RenewFlightEndpointRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.endpoint !== undefined) {
      FlightEndpoint.encode(message.endpoint, writer.uint32(10).fork()).join()
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenewFlightEndpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseRenewFlightEndpointRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.endpoint = FlightEndpoint.decode(reader, reader.uint32())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): RenewFlightEndpointRequest {
    return {
      endpoint: isSet(object.endpoint) ? FlightEndpoint.fromJSON(object.endpoint) : undefined
    }
  },

  toJSON(message: RenewFlightEndpointRequest): unknown {
    const obj: any = {}
    if (message.endpoint !== undefined) {
      obj.endpoint = FlightEndpoint.toJSON(message.endpoint)
    }
    return obj
  },

  create(base?: DeepPartial<RenewFlightEndpointRequest>): RenewFlightEndpointRequest {
    return RenewFlightEndpointRequest.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<RenewFlightEndpointRequest>): RenewFlightEndpointRequest {
    const message = createBaseRenewFlightEndpointRequest()
    message.endpoint =
      object.endpoint !== undefined && object.endpoint !== null
        ? FlightEndpoint.fromPartial(object.endpoint)
        : undefined
    return message
  }
}

function createBaseFlightData(): FlightData {
  return {
    flightDescriptor: undefined,
    dataHeader: Buffer.alloc(0),
    appMetadata: Buffer.alloc(0),
    dataBody: Buffer.alloc(0)
  }
}

export const FlightData: MessageFns<FlightData> = {
  encode(message: FlightData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flightDescriptor !== undefined) {
      FlightDescriptor.encode(message.flightDescriptor, writer.uint32(10).fork()).join()
    }
    if (message.dataHeader.length !== 0) {
      writer.uint32(18).bytes(message.dataHeader)
    }
    if (message.appMetadata.length !== 0) {
      writer.uint32(26).bytes(message.appMetadata)
    }
    if (message.dataBody.length !== 0) {
      writer.uint32(8002).bytes(message.dataBody)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlightData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseFlightData()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.flightDescriptor = FlightDescriptor.decode(reader, reader.uint32())
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.dataHeader = Buffer.from(reader.bytes())
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.appMetadata = Buffer.from(reader.bytes())
          continue
        }
        case 1000: {
          if (tag !== 8002) {
            break
          }

          message.dataBody = Buffer.from(reader.bytes())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): FlightData {
    return {
      flightDescriptor: isSet(object.flightDescriptor)
        ? FlightDescriptor.fromJSON(object.flightDescriptor)
        : undefined,
      dataHeader: isSet(object.dataHeader)
        ? Buffer.from(bytesFromBase64(object.dataHeader))
        : Buffer.alloc(0),
      appMetadata: isSet(object.appMetadata)
        ? Buffer.from(bytesFromBase64(object.appMetadata))
        : Buffer.alloc(0),
      dataBody: isSet(object.dataBody)
        ? Buffer.from(bytesFromBase64(object.dataBody))
        : Buffer.alloc(0)
    }
  },

  toJSON(message: FlightData): unknown {
    const obj: any = {}
    if (message.flightDescriptor !== undefined) {
      obj.flightDescriptor = FlightDescriptor.toJSON(message.flightDescriptor)
    }
    if (message.dataHeader.length !== 0) {
      obj.dataHeader = base64FromBytes(message.dataHeader)
    }
    if (message.appMetadata.length !== 0) {
      obj.appMetadata = base64FromBytes(message.appMetadata)
    }
    if (message.dataBody.length !== 0) {
      obj.dataBody = base64FromBytes(message.dataBody)
    }
    return obj
  },

  create(base?: DeepPartial<FlightData>): FlightData {
    return FlightData.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<FlightData>): FlightData {
    const message = createBaseFlightData()
    message.flightDescriptor =
      object.flightDescriptor !== undefined && object.flightDescriptor !== null
        ? FlightDescriptor.fromPartial(object.flightDescriptor)
        : undefined
    message.dataHeader = object.dataHeader ?? Buffer.alloc(0)
    message.appMetadata = object.appMetadata ?? Buffer.alloc(0)
    message.dataBody = object.dataBody ?? Buffer.alloc(0)
    return message
  }
}

function createBasePutResult(): PutResult {
  return { appMetadata: Buffer.alloc(0) }
}

export const PutResult: MessageFns<PutResult> = {
  encode(message: PutResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appMetadata.length !== 0) {
      writer.uint32(10).bytes(message.appMetadata)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PutResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBasePutResult()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.appMetadata = Buffer.from(reader.bytes())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): PutResult {
    return {
      appMetadata: isSet(object.appMetadata)
        ? Buffer.from(bytesFromBase64(object.appMetadata))
        : Buffer.alloc(0)
    }
  },

  toJSON(message: PutResult): unknown {
    const obj: any = {}
    if (message.appMetadata.length !== 0) {
      obj.appMetadata = base64FromBytes(message.appMetadata)
    }
    return obj
  },

  create(base?: DeepPartial<PutResult>): PutResult {
    return PutResult.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<PutResult>): PutResult {
    const message = createBasePutResult()
    message.appMetadata = object.appMetadata ?? Buffer.alloc(0)
    return message
  }
}

function createBaseSessionOptionValue(): SessionOptionValue {
  return {
    stringValue: undefined,
    boolValue: undefined,
    int64Value: undefined,
    doubleValue: undefined,
    stringListValue: undefined
  }
}

export const SessionOptionValue: MessageFns<SessionOptionValue> = {
  encode(message: SessionOptionValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringValue !== undefined) {
      writer.uint32(10).string(message.stringValue)
    }
    if (message.boolValue !== undefined) {
      writer.uint32(16).bool(message.boolValue)
    }
    if (message.int64Value !== undefined) {
      writer.uint32(25).sfixed64(message.int64Value)
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(33).double(message.doubleValue)
    }
    if (message.stringListValue !== undefined) {
      SessionOptionValue_StringListValue.encode(
        message.stringListValue,
        writer.uint32(42).fork()
      ).join()
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionOptionValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseSessionOptionValue()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.stringValue = reader.string()
          continue
        }
        case 2: {
          if (tag !== 16) {
            break
          }

          message.boolValue = reader.bool()
          continue
        }
        case 3: {
          if (tag !== 25) {
            break
          }

          message.int64Value = longToNumber(reader.sfixed64())
          continue
        }
        case 4: {
          if (tag !== 33) {
            break
          }

          message.doubleValue = reader.double()
          continue
        }
        case 5: {
          if (tag !== 42) {
            break
          }

          message.stringListValue = SessionOptionValue_StringListValue.decode(
            reader,
            reader.uint32()
          )
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): SessionOptionValue {
    return {
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      int64Value: isSet(object.int64Value) ? globalThis.Number(object.int64Value) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
      stringListValue: isSet(object.stringListValue)
        ? SessionOptionValue_StringListValue.fromJSON(object.stringListValue)
        : undefined
    }
  },

  toJSON(message: SessionOptionValue): unknown {
    const obj: any = {}
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue
    }
    if (message.int64Value !== undefined) {
      obj.int64Value = Math.round(message.int64Value)
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue
    }
    if (message.stringListValue !== undefined) {
      obj.stringListValue = SessionOptionValue_StringListValue.toJSON(message.stringListValue)
    }
    return obj
  },

  create(base?: DeepPartial<SessionOptionValue>): SessionOptionValue {
    return SessionOptionValue.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<SessionOptionValue>): SessionOptionValue {
    const message = createBaseSessionOptionValue()
    message.stringValue = object.stringValue ?? undefined
    message.boolValue = object.boolValue ?? undefined
    message.int64Value = object.int64Value ?? undefined
    message.doubleValue = object.doubleValue ?? undefined
    message.stringListValue =
      object.stringListValue !== undefined && object.stringListValue !== null
        ? SessionOptionValue_StringListValue.fromPartial(object.stringListValue)
        : undefined
    return message
  }
}

function createBaseSessionOptionValue_StringListValue(): SessionOptionValue_StringListValue {
  return { values: [] }
}

export const SessionOptionValue_StringListValue: MessageFns<SessionOptionValue_StringListValue> = {
  encode(
    message: SessionOptionValue_StringListValue,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionOptionValue_StringListValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseSessionOptionValue_StringListValue()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.values.push(reader.string())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): SessionOptionValue_StringListValue {
    return {
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => globalThis.String(e))
        : []
    }
  },

  toJSON(message: SessionOptionValue_StringListValue): unknown {
    const obj: any = {}
    if (message.values?.length) {
      obj.values = message.values
    }
    return obj
  },

  create(
    base?: DeepPartial<SessionOptionValue_StringListValue>
  ): SessionOptionValue_StringListValue {
    return SessionOptionValue_StringListValue.fromPartial(base ?? {})
  },
  fromPartial(
    object: DeepPartial<SessionOptionValue_StringListValue>
  ): SessionOptionValue_StringListValue {
    const message = createBaseSessionOptionValue_StringListValue()
    message.values = object.values?.map((e) => e) || []
    return message
  }
}

function createBaseSetSessionOptionsRequest(): SetSessionOptionsRequest {
  return { sessionOptions: {} }
}

export const SetSessionOptionsRequest: MessageFns<SetSessionOptionsRequest> = {
  encode(
    message: SetSessionOptionsRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    Object.entries(message.sessionOptions).forEach(([key, value]) => {
      SetSessionOptionsRequest_SessionOptionsEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork()
      ).join()
    })
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetSessionOptionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseSetSessionOptionsRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          const entry1 = SetSessionOptionsRequest_SessionOptionsEntry.decode(
            reader,
            reader.uint32()
          )
          if (entry1.value !== undefined) {
            message.sessionOptions[entry1.key] = entry1.value
          }
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): SetSessionOptionsRequest {
    return {
      sessionOptions: isObject(object.sessionOptions)
        ? Object.entries(object.sessionOptions).reduce<{ [key: string]: SessionOptionValue }>(
            (acc, [key, value]) => {
              acc[key] = SessionOptionValue.fromJSON(value)
              return acc
            },
            {}
          )
        : {}
    }
  },

  toJSON(message: SetSessionOptionsRequest): unknown {
    const obj: any = {}
    if (message.sessionOptions) {
      const entries = Object.entries(message.sessionOptions)
      if (entries.length > 0) {
        obj.sessionOptions = {}
        entries.forEach(([k, v]) => {
          obj.sessionOptions[k] = SessionOptionValue.toJSON(v)
        })
      }
    }
    return obj
  },

  create(base?: DeepPartial<SetSessionOptionsRequest>): SetSessionOptionsRequest {
    return SetSessionOptionsRequest.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<SetSessionOptionsRequest>): SetSessionOptionsRequest {
    const message = createBaseSetSessionOptionsRequest()
    message.sessionOptions = Object.entries(object.sessionOptions ?? {}).reduce<{
      [key: string]: SessionOptionValue
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SessionOptionValue.fromPartial(value)
      }
      return acc
    }, {})
    return message
  }
}

function createBaseSetSessionOptionsRequest_SessionOptionsEntry(): SetSessionOptionsRequest_SessionOptionsEntry {
  return { key: "", value: undefined }
}

export const SetSessionOptionsRequest_SessionOptionsEntry: MessageFns<SetSessionOptionsRequest_SessionOptionsEntry> =
  {
    encode(
      message: SetSessionOptionsRequest_SessionOptionsEntry,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key)
      }
      if (message.value !== undefined) {
        SessionOptionValue.encode(message.value, writer.uint32(18).fork()).join()
      }
      return writer
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): SetSessionOptionsRequest_SessionOptionsEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
      let end = length === undefined ? reader.len : reader.pos + length
      const message = createBaseSetSessionOptionsRequest_SessionOptionsEntry()
      while (reader.pos < end) {
        const tag = reader.uint32()
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break
            }

            message.key = reader.string()
            continue
          }
          case 2: {
            if (tag !== 18) {
              break
            }

            message.value = SessionOptionValue.decode(reader, reader.uint32())
            continue
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break
        }
        reader.skip(tag & 7)
      }
      return message
    },

    fromJSON(object: any): SetSessionOptionsRequest_SessionOptionsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? SessionOptionValue.fromJSON(object.value) : undefined
      }
    },

    toJSON(message: SetSessionOptionsRequest_SessionOptionsEntry): unknown {
      const obj: any = {}
      if (message.key !== "") {
        obj.key = message.key
      }
      if (message.value !== undefined) {
        obj.value = SessionOptionValue.toJSON(message.value)
      }
      return obj
    },

    create(
      base?: DeepPartial<SetSessionOptionsRequest_SessionOptionsEntry>
    ): SetSessionOptionsRequest_SessionOptionsEntry {
      return SetSessionOptionsRequest_SessionOptionsEntry.fromPartial(base ?? {})
    },
    fromPartial(
      object: DeepPartial<SetSessionOptionsRequest_SessionOptionsEntry>
    ): SetSessionOptionsRequest_SessionOptionsEntry {
      const message = createBaseSetSessionOptionsRequest_SessionOptionsEntry()
      message.key = object.key ?? ""
      message.value =
        object.value !== undefined && object.value !== null
          ? SessionOptionValue.fromPartial(object.value)
          : undefined
      return message
    }
  }

function createBaseSetSessionOptionsResult(): SetSessionOptionsResult {
  return { errors: {} }
}

export const SetSessionOptionsResult: MessageFns<SetSessionOptionsResult> = {
  encode(
    message: SetSessionOptionsResult,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    Object.entries(message.errors).forEach(([key, value]) => {
      SetSessionOptionsResult_ErrorsEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork()
      ).join()
    })
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetSessionOptionsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseSetSessionOptionsResult()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          const entry1 = SetSessionOptionsResult_ErrorsEntry.decode(reader, reader.uint32())
          if (entry1.value !== undefined) {
            message.errors[entry1.key] = entry1.value
          }
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): SetSessionOptionsResult {
    return {
      errors: isObject(object.errors)
        ? Object.entries(object.errors).reduce<{ [key: string]: SetSessionOptionsResult_Error }>(
            (acc, [key, value]) => {
              acc[key] = SetSessionOptionsResult_Error.fromJSON(value)
              return acc
            },
            {}
          )
        : {}
    }
  },

  toJSON(message: SetSessionOptionsResult): unknown {
    const obj: any = {}
    if (message.errors) {
      const entries = Object.entries(message.errors)
      if (entries.length > 0) {
        obj.errors = {}
        entries.forEach(([k, v]) => {
          obj.errors[k] = SetSessionOptionsResult_Error.toJSON(v)
        })
      }
    }
    return obj
  },

  create(base?: DeepPartial<SetSessionOptionsResult>): SetSessionOptionsResult {
    return SetSessionOptionsResult.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<SetSessionOptionsResult>): SetSessionOptionsResult {
    const message = createBaseSetSessionOptionsResult()
    message.errors = Object.entries(object.errors ?? {}).reduce<{
      [key: string]: SetSessionOptionsResult_Error
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SetSessionOptionsResult_Error.fromPartial(value)
      }
      return acc
    }, {})
    return message
  }
}

function createBaseSetSessionOptionsResult_Error(): SetSessionOptionsResult_Error {
  return { value: 0 }
}

export const SetSessionOptionsResult_Error: MessageFns<SetSessionOptionsResult_Error> = {
  encode(
    message: SetSessionOptionsResult_Error,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetSessionOptionsResult_Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseSetSessionOptionsResult_Error()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break
          }

          message.value = reader.int32() as any
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): SetSessionOptionsResult_Error {
    return {
      value: isSet(object.value) ? setSessionOptionsResult_ErrorValueFromJSON(object.value) : 0
    }
  },

  toJSON(message: SetSessionOptionsResult_Error): unknown {
    const obj: any = {}
    if (message.value !== 0) {
      obj.value = setSessionOptionsResult_ErrorValueToJSON(message.value)
    }
    return obj
  },

  create(base?: DeepPartial<SetSessionOptionsResult_Error>): SetSessionOptionsResult_Error {
    return SetSessionOptionsResult_Error.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<SetSessionOptionsResult_Error>): SetSessionOptionsResult_Error {
    const message = createBaseSetSessionOptionsResult_Error()
    message.value = object.value ?? 0
    return message
  }
}

function createBaseSetSessionOptionsResult_ErrorsEntry(): SetSessionOptionsResult_ErrorsEntry {
  return { key: "", value: undefined }
}

export const SetSessionOptionsResult_ErrorsEntry: MessageFns<SetSessionOptionsResult_ErrorsEntry> =
  {
    encode(
      message: SetSessionOptionsResult_ErrorsEntry,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key)
      }
      if (message.value !== undefined) {
        SetSessionOptionsResult_Error.encode(message.value, writer.uint32(18).fork()).join()
      }
      return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): SetSessionOptionsResult_ErrorsEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
      let end = length === undefined ? reader.len : reader.pos + length
      const message = createBaseSetSessionOptionsResult_ErrorsEntry()
      while (reader.pos < end) {
        const tag = reader.uint32()
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break
            }

            message.key = reader.string()
            continue
          }
          case 2: {
            if (tag !== 18) {
              break
            }

            message.value = SetSessionOptionsResult_Error.decode(reader, reader.uint32())
            continue
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break
        }
        reader.skip(tag & 7)
      }
      return message
    },

    fromJSON(object: any): SetSessionOptionsResult_ErrorsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value)
          ? SetSessionOptionsResult_Error.fromJSON(object.value)
          : undefined
      }
    },

    toJSON(message: SetSessionOptionsResult_ErrorsEntry): unknown {
      const obj: any = {}
      if (message.key !== "") {
        obj.key = message.key
      }
      if (message.value !== undefined) {
        obj.value = SetSessionOptionsResult_Error.toJSON(message.value)
      }
      return obj
    },

    create(
      base?: DeepPartial<SetSessionOptionsResult_ErrorsEntry>
    ): SetSessionOptionsResult_ErrorsEntry {
      return SetSessionOptionsResult_ErrorsEntry.fromPartial(base ?? {})
    },
    fromPartial(
      object: DeepPartial<SetSessionOptionsResult_ErrorsEntry>
    ): SetSessionOptionsResult_ErrorsEntry {
      const message = createBaseSetSessionOptionsResult_ErrorsEntry()
      message.key = object.key ?? ""
      message.value =
        object.value !== undefined && object.value !== null
          ? SetSessionOptionsResult_Error.fromPartial(object.value)
          : undefined
      return message
    }
  }

function createBaseGetSessionOptionsRequest(): GetSessionOptionsRequest {
  return {}
}

export const GetSessionOptionsRequest: MessageFns<GetSessionOptionsRequest> = {
  encode(_: GetSessionOptionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSessionOptionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseGetSessionOptionsRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(_: any): GetSessionOptionsRequest {
    return {}
  },

  toJSON(_: GetSessionOptionsRequest): unknown {
    const obj: any = {}
    return obj
  },

  create(base?: DeepPartial<GetSessionOptionsRequest>): GetSessionOptionsRequest {
    return GetSessionOptionsRequest.fromPartial(base ?? {})
  },
  fromPartial(_: DeepPartial<GetSessionOptionsRequest>): GetSessionOptionsRequest {
    const message = createBaseGetSessionOptionsRequest()
    return message
  }
}

function createBaseGetSessionOptionsResult(): GetSessionOptionsResult {
  return { sessionOptions: {} }
}

export const GetSessionOptionsResult: MessageFns<GetSessionOptionsResult> = {
  encode(
    message: GetSessionOptionsResult,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    Object.entries(message.sessionOptions).forEach(([key, value]) => {
      GetSessionOptionsResult_SessionOptionsEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork()
      ).join()
    })
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSessionOptionsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseGetSessionOptionsResult()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          const entry1 = GetSessionOptionsResult_SessionOptionsEntry.decode(reader, reader.uint32())
          if (entry1.value !== undefined) {
            message.sessionOptions[entry1.key] = entry1.value
          }
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): GetSessionOptionsResult {
    return {
      sessionOptions: isObject(object.sessionOptions)
        ? Object.entries(object.sessionOptions).reduce<{ [key: string]: SessionOptionValue }>(
            (acc, [key, value]) => {
              acc[key] = SessionOptionValue.fromJSON(value)
              return acc
            },
            {}
          )
        : {}
    }
  },

  toJSON(message: GetSessionOptionsResult): unknown {
    const obj: any = {}
    if (message.sessionOptions) {
      const entries = Object.entries(message.sessionOptions)
      if (entries.length > 0) {
        obj.sessionOptions = {}
        entries.forEach(([k, v]) => {
          obj.sessionOptions[k] = SessionOptionValue.toJSON(v)
        })
      }
    }
    return obj
  },

  create(base?: DeepPartial<GetSessionOptionsResult>): GetSessionOptionsResult {
    return GetSessionOptionsResult.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<GetSessionOptionsResult>): GetSessionOptionsResult {
    const message = createBaseGetSessionOptionsResult()
    message.sessionOptions = Object.entries(object.sessionOptions ?? {}).reduce<{
      [key: string]: SessionOptionValue
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SessionOptionValue.fromPartial(value)
      }
      return acc
    }, {})
    return message
  }
}

function createBaseGetSessionOptionsResult_SessionOptionsEntry(): GetSessionOptionsResult_SessionOptionsEntry {
  return { key: "", value: undefined }
}

export const GetSessionOptionsResult_SessionOptionsEntry: MessageFns<GetSessionOptionsResult_SessionOptionsEntry> =
  {
    encode(
      message: GetSessionOptionsResult_SessionOptionsEntry,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key)
      }
      if (message.value !== undefined) {
        SessionOptionValue.encode(message.value, writer.uint32(18).fork()).join()
      }
      return writer
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): GetSessionOptionsResult_SessionOptionsEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
      let end = length === undefined ? reader.len : reader.pos + length
      const message = createBaseGetSessionOptionsResult_SessionOptionsEntry()
      while (reader.pos < end) {
        const tag = reader.uint32()
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break
            }

            message.key = reader.string()
            continue
          }
          case 2: {
            if (tag !== 18) {
              break
            }

            message.value = SessionOptionValue.decode(reader, reader.uint32())
            continue
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break
        }
        reader.skip(tag & 7)
      }
      return message
    },

    fromJSON(object: any): GetSessionOptionsResult_SessionOptionsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? SessionOptionValue.fromJSON(object.value) : undefined
      }
    },

    toJSON(message: GetSessionOptionsResult_SessionOptionsEntry): unknown {
      const obj: any = {}
      if (message.key !== "") {
        obj.key = message.key
      }
      if (message.value !== undefined) {
        obj.value = SessionOptionValue.toJSON(message.value)
      }
      return obj
    },

    create(
      base?: DeepPartial<GetSessionOptionsResult_SessionOptionsEntry>
    ): GetSessionOptionsResult_SessionOptionsEntry {
      return GetSessionOptionsResult_SessionOptionsEntry.fromPartial(base ?? {})
    },
    fromPartial(
      object: DeepPartial<GetSessionOptionsResult_SessionOptionsEntry>
    ): GetSessionOptionsResult_SessionOptionsEntry {
      const message = createBaseGetSessionOptionsResult_SessionOptionsEntry()
      message.key = object.key ?? ""
      message.value =
        object.value !== undefined && object.value !== null
          ? SessionOptionValue.fromPartial(object.value)
          : undefined
      return message
    }
  }

function createBaseCloseSessionRequest(): CloseSessionRequest {
  return {}
}

export const CloseSessionRequest: MessageFns<CloseSessionRequest> = {
  encode(_: CloseSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloseSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseCloseSessionRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(_: any): CloseSessionRequest {
    return {}
  },

  toJSON(_: CloseSessionRequest): unknown {
    const obj: any = {}
    return obj
  },

  create(base?: DeepPartial<CloseSessionRequest>): CloseSessionRequest {
    return CloseSessionRequest.fromPartial(base ?? {})
  },
  fromPartial(_: DeepPartial<CloseSessionRequest>): CloseSessionRequest {
    const message = createBaseCloseSessionRequest()
    return message
  }
}

function createBaseCloseSessionResult(): CloseSessionResult {
  return { status: 0 }
}

export const CloseSessionResult: MessageFns<CloseSessionResult> = {
  encode(message: CloseSessionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloseSessionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseCloseSessionResult()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break
          }

          message.status = reader.int32() as any
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): CloseSessionResult {
    return { status: isSet(object.status) ? closeSessionResult_StatusFromJSON(object.status) : 0 }
  },

  toJSON(message: CloseSessionResult): unknown {
    const obj: any = {}
    if (message.status !== 0) {
      obj.status = closeSessionResult_StatusToJSON(message.status)
    }
    return obj
  },

  create(base?: DeepPartial<CloseSessionResult>): CloseSessionResult {
    return CloseSessionResult.fromPartial(base ?? {})
  },
  fromPartial(object: DeepPartial<CloseSessionResult>): CloseSessionResult {
    const message = createBaseCloseSessionResult()
    message.status = object.status ?? 0
    return message
  }
}

/**
 * A flight service is an endpoint for retrieving or storing Arrow data. A
 * flight service can expose one or more predefined endpoints that can be
 * accessed using the Arrow Flight Protocol. Additionally, a flight service
 * can expose a set of actions that are available.
 */
export type FlightServiceService = typeof FlightServiceService
export const FlightServiceService = {
  /**
   * Handshake between client and server. Depending on the server, the
   * handshake may be required to determine the token that should be used for
   * future operations. Both request and response are streams to allow multiple
   * round-trips depending on auth mechanism.
   */
  handshake: {
    path: "/arrow.flight.protocol.FlightService/Handshake",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: HandshakeRequest) =>
      Buffer.from(HandshakeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => HandshakeRequest.decode(value),
    responseSerialize: (value: HandshakeResponse) =>
      Buffer.from(HandshakeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HandshakeResponse.decode(value)
  },
  /**
   * Get a list of available streams given a particular criteria. Most flight
   * services will expose one or more streams that are readily available for
   * retrieval. This api allows listing the streams available for
   * consumption. A user can also provide a criteria. The criteria can limit
   * the subset of streams that can be listed via this interface. Each flight
   * service allows its own definition of how to consume criteria.
   */
  listFlights: {
    path: "/arrow.flight.protocol.FlightService/ListFlights",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: Criteria) => Buffer.from(Criteria.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Criteria.decode(value),
    responseSerialize: (value: FlightInfo) => Buffer.from(FlightInfo.encode(value).finish()),
    responseDeserialize: (value: Buffer) => FlightInfo.decode(value)
  },
  /**
   * For a given FlightDescriptor, get information about how the flight can be
   * consumed. This is a useful interface if the consumer of the interface
   * already can identify the specific flight to consume. This interface can
   * also allow a consumer to generate a flight stream through a specified
   * descriptor. For example, a flight descriptor might be something that
   * includes a SQL statement or a Pickled Python operation that will be
   * executed. In those cases, the descriptor will not be previously available
   * within the list of available streams provided by ListFlights but will be
   * available for consumption for the duration defined by the specific flight
   * service.
   */
  getFlightInfo: {
    path: "/arrow.flight.protocol.FlightService/GetFlightInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FlightDescriptor) =>
      Buffer.from(FlightDescriptor.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FlightDescriptor.decode(value),
    responseSerialize: (value: FlightInfo) => Buffer.from(FlightInfo.encode(value).finish()),
    responseDeserialize: (value: Buffer) => FlightInfo.decode(value)
  },
  /**
   * For a given FlightDescriptor, start a query and get information
   * to poll its execution status. This is a useful interface if the
   * query may be a long-running query. The first PollFlightInfo call
   * should return as quickly as possible. (GetFlightInfo doesn't
   * return until the query is complete.)
   *
   * A client can consume any available results before
   * the query is completed. See PollInfo.info for details.
   *
   * A client can poll the updated query status by calling
   * PollFlightInfo() with PollInfo.flight_descriptor. A server
   * should not respond until the result would be different from last
   * time. That way, the client can "long poll" for updates
   * without constantly making requests. Clients can set a short timeout
   * to avoid blocking calls if desired.
   *
   * A client can't use PollInfo.flight_descriptor after
   * PollInfo.expiration_time passes. A server might not accept the
   * retry descriptor anymore and the query may be cancelled.
   *
   * A client may use the CancelFlightInfo action with
   * PollInfo.info to cancel the running query.
   */
  pollFlightInfo: {
    path: "/arrow.flight.protocol.FlightService/PollFlightInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FlightDescriptor) =>
      Buffer.from(FlightDescriptor.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FlightDescriptor.decode(value),
    responseSerialize: (value: PollInfo) => Buffer.from(PollInfo.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PollInfo.decode(value)
  },
  /**
   * For a given FlightDescriptor, get the Schema as described in Schema.fbs::Schema
   * This is used when a consumer needs the Schema of flight stream. Similar to
   * GetFlightInfo this interface may generate a new flight that was not previously
   * available in ListFlights.
   */
  getSchema: {
    path: "/arrow.flight.protocol.FlightService/GetSchema",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FlightDescriptor) =>
      Buffer.from(FlightDescriptor.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FlightDescriptor.decode(value),
    responseSerialize: (value: SchemaResult) => Buffer.from(SchemaResult.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SchemaResult.decode(value)
  },
  /**
   * Retrieve a single stream associated with a particular descriptor
   * associated with the referenced ticket. A Flight can be composed of one or
   * more streams where each stream can be retrieved using a separate opaque
   * ticket that the flight service uses for managing a collection of streams.
   */
  doGet: {
    path: "/arrow.flight.protocol.FlightService/DoGet",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: Ticket) => Buffer.from(Ticket.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Ticket.decode(value),
    responseSerialize: (value: FlightData) => Buffer.from(FlightData.encode(value).finish()),
    responseDeserialize: (value: Buffer) => FlightData.decode(value)
  },
  /**
   * Push a stream to the flight service associated with a particular
   * flight stream. This allows a client of a flight service to upload a stream
   * of data. Depending on the particular flight service, a client consumer
   * could be allowed to upload a single stream per descriptor or an unlimited
   * number. In the latter, the service might implement a 'seal' action that
   * can be applied to a descriptor once all streams are uploaded.
   */
  doPut: {
    path: "/arrow.flight.protocol.FlightService/DoPut",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: FlightData) => Buffer.from(FlightData.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FlightData.decode(value),
    responseSerialize: (value: PutResult) => Buffer.from(PutResult.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PutResult.decode(value)
  },
  /**
   * Open a bidirectional data channel for a given descriptor. This
   * allows clients to send and receive arbitrary Arrow data and
   * application-specific metadata in a single logical stream. In
   * contrast to DoGet/DoPut, this is more suited for clients
   * offloading computation (rather than storage) to a Flight service.
   */
  doExchange: {
    path: "/arrow.flight.protocol.FlightService/DoExchange",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: FlightData) => Buffer.from(FlightData.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FlightData.decode(value),
    responseSerialize: (value: FlightData) => Buffer.from(FlightData.encode(value).finish()),
    responseDeserialize: (value: Buffer) => FlightData.decode(value)
  },
  /**
   * Flight services can support an arbitrary number of simple actions in
   * addition to the possible ListFlights, GetFlightInfo, DoGet, DoPut
   * operations that are potentially available. DoAction allows a flight client
   * to do a specific action against a flight service. An action includes
   * opaque request and response objects that are specific to the type action
   * being undertaken.
   */
  doAction: {
    path: "/arrow.flight.protocol.FlightService/DoAction",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: Action) => Buffer.from(Action.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Action.decode(value),
    responseSerialize: (value: Result) => Buffer.from(Result.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Result.decode(value)
  },
  /**
   * A flight service exposes all of the available action types that it has
   * along with descriptions. This allows different flight consumers to
   * understand the capabilities of the flight service.
   */
  listActions: {
    path: "/arrow.flight.protocol.FlightService/ListActions",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: ActionType) => Buffer.from(ActionType.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ActionType.decode(value)
  }
} as const

export interface FlightServiceServer extends UntypedServiceImplementation {
  /**
   * Handshake between client and server. Depending on the server, the
   * handshake may be required to determine the token that should be used for
   * future operations. Both request and response are streams to allow multiple
   * round-trips depending on auth mechanism.
   */
  handshake: handleBidiStreamingCall<HandshakeRequest, HandshakeResponse>
  /**
   * Get a list of available streams given a particular criteria. Most flight
   * services will expose one or more streams that are readily available for
   * retrieval. This api allows listing the streams available for
   * consumption. A user can also provide a criteria. The criteria can limit
   * the subset of streams that can be listed via this interface. Each flight
   * service allows its own definition of how to consume criteria.
   */
  listFlights: handleServerStreamingCall<Criteria, FlightInfo>
  /**
   * For a given FlightDescriptor, get information about how the flight can be
   * consumed. This is a useful interface if the consumer of the interface
   * already can identify the specific flight to consume. This interface can
   * also allow a consumer to generate a flight stream through a specified
   * descriptor. For example, a flight descriptor might be something that
   * includes a SQL statement or a Pickled Python operation that will be
   * executed. In those cases, the descriptor will not be previously available
   * within the list of available streams provided by ListFlights but will be
   * available for consumption for the duration defined by the specific flight
   * service.
   */
  getFlightInfo: handleUnaryCall<FlightDescriptor, FlightInfo>
  /**
   * For a given FlightDescriptor, start a query and get information
   * to poll its execution status. This is a useful interface if the
   * query may be a long-running query. The first PollFlightInfo call
   * should return as quickly as possible. (GetFlightInfo doesn't
   * return until the query is complete.)
   *
   * A client can consume any available results before
   * the query is completed. See PollInfo.info for details.
   *
   * A client can poll the updated query status by calling
   * PollFlightInfo() with PollInfo.flight_descriptor. A server
   * should not respond until the result would be different from last
   * time. That way, the client can "long poll" for updates
   * without constantly making requests. Clients can set a short timeout
   * to avoid blocking calls if desired.
   *
   * A client can't use PollInfo.flight_descriptor after
   * PollInfo.expiration_time passes. A server might not accept the
   * retry descriptor anymore and the query may be cancelled.
   *
   * A client may use the CancelFlightInfo action with
   * PollInfo.info to cancel the running query.
   */
  pollFlightInfo: handleUnaryCall<FlightDescriptor, PollInfo>
  /**
   * For a given FlightDescriptor, get the Schema as described in Schema.fbs::Schema
   * This is used when a consumer needs the Schema of flight stream. Similar to
   * GetFlightInfo this interface may generate a new flight that was not previously
   * available in ListFlights.
   */
  getSchema: handleUnaryCall<FlightDescriptor, SchemaResult>
  /**
   * Retrieve a single stream associated with a particular descriptor
   * associated with the referenced ticket. A Flight can be composed of one or
   * more streams where each stream can be retrieved using a separate opaque
   * ticket that the flight service uses for managing a collection of streams.
   */
  doGet: handleServerStreamingCall<Ticket, FlightData>
  /**
   * Push a stream to the flight service associated with a particular
   * flight stream. This allows a client of a flight service to upload a stream
   * of data. Depending on the particular flight service, a client consumer
   * could be allowed to upload a single stream per descriptor or an unlimited
   * number. In the latter, the service might implement a 'seal' action that
   * can be applied to a descriptor once all streams are uploaded.
   */
  doPut: handleBidiStreamingCall<FlightData, PutResult>
  /**
   * Open a bidirectional data channel for a given descriptor. This
   * allows clients to send and receive arbitrary Arrow data and
   * application-specific metadata in a single logical stream. In
   * contrast to DoGet/DoPut, this is more suited for clients
   * offloading computation (rather than storage) to a Flight service.
   */
  doExchange: handleBidiStreamingCall<FlightData, FlightData>
  /**
   * Flight services can support an arbitrary number of simple actions in
   * addition to the possible ListFlights, GetFlightInfo, DoGet, DoPut
   * operations that are potentially available. DoAction allows a flight client
   * to do a specific action against a flight service. An action includes
   * opaque request and response objects that are specific to the type action
   * being undertaken.
   */
  doAction: handleServerStreamingCall<Action, Result>
  /**
   * A flight service exposes all of the available action types that it has
   * along with descriptions. This allows different flight consumers to
   * understand the capabilities of the flight service.
   */
  listActions: handleServerStreamingCall<Empty, ActionType>
}

export interface FlightServiceClient extends Client {
  /**
   * Handshake between client and server. Depending on the server, the
   * handshake may be required to determine the token that should be used for
   * future operations. Both request and response are streams to allow multiple
   * round-trips depending on auth mechanism.
   */
  handshake(): ClientDuplexStream<HandshakeRequest, HandshakeResponse>
  handshake(options: Partial<CallOptions>): ClientDuplexStream<HandshakeRequest, HandshakeResponse>
  handshake(
    metadata: Metadata,
    options?: Partial<CallOptions>
  ): ClientDuplexStream<HandshakeRequest, HandshakeResponse>
  /**
   * Get a list of available streams given a particular criteria. Most flight
   * services will expose one or more streams that are readily available for
   * retrieval. This api allows listing the streams available for
   * consumption. A user can also provide a criteria. The criteria can limit
   * the subset of streams that can be listed via this interface. Each flight
   * service allows its own definition of how to consume criteria.
   */
  listFlights(request: Criteria, options?: Partial<CallOptions>): ClientReadableStream<FlightInfo>
  listFlights(
    request: Criteria,
    metadata?: Metadata,
    options?: Partial<CallOptions>
  ): ClientReadableStream<FlightInfo>
  /**
   * For a given FlightDescriptor, get information about how the flight can be
   * consumed. This is a useful interface if the consumer of the interface
   * already can identify the specific flight to consume. This interface can
   * also allow a consumer to generate a flight stream through a specified
   * descriptor. For example, a flight descriptor might be something that
   * includes a SQL statement or a Pickled Python operation that will be
   * executed. In those cases, the descriptor will not be previously available
   * within the list of available streams provided by ListFlights but will be
   * available for consumption for the duration defined by the specific flight
   * service.
   */
  getFlightInfo(
    request: FlightDescriptor,
    callback: (error: ServiceError | null, response: FlightInfo) => void
  ): ClientUnaryCall
  getFlightInfo(
    request: FlightDescriptor,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: FlightInfo) => void
  ): ClientUnaryCall
  getFlightInfo(
    request: FlightDescriptor,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: FlightInfo) => void
  ): ClientUnaryCall
  /**
   * For a given FlightDescriptor, start a query and get information
   * to poll its execution status. This is a useful interface if the
   * query may be a long-running query. The first PollFlightInfo call
   * should return as quickly as possible. (GetFlightInfo doesn't
   * return until the query is complete.)
   *
   * A client can consume any available results before
   * the query is completed. See PollInfo.info for details.
   *
   * A client can poll the updated query status by calling
   * PollFlightInfo() with PollInfo.flight_descriptor. A server
   * should not respond until the result would be different from last
   * time. That way, the client can "long poll" for updates
   * without constantly making requests. Clients can set a short timeout
   * to avoid blocking calls if desired.
   *
   * A client can't use PollInfo.flight_descriptor after
   * PollInfo.expiration_time passes. A server might not accept the
   * retry descriptor anymore and the query may be cancelled.
   *
   * A client may use the CancelFlightInfo action with
   * PollInfo.info to cancel the running query.
   */
  pollFlightInfo(
    request: FlightDescriptor,
    callback: (error: ServiceError | null, response: PollInfo) => void
  ): ClientUnaryCall
  pollFlightInfo(
    request: FlightDescriptor,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PollInfo) => void
  ): ClientUnaryCall
  pollFlightInfo(
    request: FlightDescriptor,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PollInfo) => void
  ): ClientUnaryCall
  /**
   * For a given FlightDescriptor, get the Schema as described in Schema.fbs::Schema
   * This is used when a consumer needs the Schema of flight stream. Similar to
   * GetFlightInfo this interface may generate a new flight that was not previously
   * available in ListFlights.
   */
  getSchema(
    request: FlightDescriptor,
    callback: (error: ServiceError | null, response: SchemaResult) => void
  ): ClientUnaryCall
  getSchema(
    request: FlightDescriptor,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SchemaResult) => void
  ): ClientUnaryCall
  getSchema(
    request: FlightDescriptor,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SchemaResult) => void
  ): ClientUnaryCall
  /**
   * Retrieve a single stream associated with a particular descriptor
   * associated with the referenced ticket. A Flight can be composed of one or
   * more streams where each stream can be retrieved using a separate opaque
   * ticket that the flight service uses for managing a collection of streams.
   */
  doGet(request: Ticket, options?: Partial<CallOptions>): ClientReadableStream<FlightData>
  doGet(
    request: Ticket,
    metadata?: Metadata,
    options?: Partial<CallOptions>
  ): ClientReadableStream<FlightData>
  /**
   * Push a stream to the flight service associated with a particular
   * flight stream. This allows a client of a flight service to upload a stream
   * of data. Depending on the particular flight service, a client consumer
   * could be allowed to upload a single stream per descriptor or an unlimited
   * number. In the latter, the service might implement a 'seal' action that
   * can be applied to a descriptor once all streams are uploaded.
   */
  doPut(): ClientDuplexStream<FlightData, PutResult>
  doPut(options: Partial<CallOptions>): ClientDuplexStream<FlightData, PutResult>
  doPut(
    metadata: Metadata,
    options?: Partial<CallOptions>
  ): ClientDuplexStream<FlightData, PutResult>
  /**
   * Open a bidirectional data channel for a given descriptor. This
   * allows clients to send and receive arbitrary Arrow data and
   * application-specific metadata in a single logical stream. In
   * contrast to DoGet/DoPut, this is more suited for clients
   * offloading computation (rather than storage) to a Flight service.
   */
  doExchange(): ClientDuplexStream<FlightData, FlightData>
  doExchange(options: Partial<CallOptions>): ClientDuplexStream<FlightData, FlightData>
  doExchange(
    metadata: Metadata,
    options?: Partial<CallOptions>
  ): ClientDuplexStream<FlightData, FlightData>
  /**
   * Flight services can support an arbitrary number of simple actions in
   * addition to the possible ListFlights, GetFlightInfo, DoGet, DoPut
   * operations that are potentially available. DoAction allows a flight client
   * to do a specific action against a flight service. An action includes
   * opaque request and response objects that are specific to the type action
   * being undertaken.
   */
  doAction(request: Action, options?: Partial<CallOptions>): ClientReadableStream<Result>
  doAction(
    request: Action,
    metadata?: Metadata,
    options?: Partial<CallOptions>
  ): ClientReadableStream<Result>
  /**
   * A flight service exposes all of the available action types that it has
   * along with descriptions. This allows different flight consumers to
   * understand the capabilities of the flight service.
   */
  listActions(request: Empty, options?: Partial<CallOptions>): ClientReadableStream<ActionType>
  listActions(
    request: Empty,
    metadata?: Metadata,
    options?: Partial<CallOptions>
  ): ClientReadableStream<ActionType>
}

export const FlightServiceClient = makeGenericClientConstructor(
  FlightServiceService,
  "arrow.flight.protocol.FlightService"
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>
  ): FlightServiceClient
  service: typeof FlightServiceService
  serviceName: string
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"))
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64")
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000)
  const nanos = (date.getTime() % 1_000) * 1_000_000
  return { seconds, nanos }
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000
  millis += (t.nanos || 0) / 1_000_000
  return new globalThis.Date(millis)
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o
  } else if (typeof o === "string") {
    return new globalThis.Date(o)
  } else {
    return fromTimestamp(Timestamp.fromJSON(o))
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString())
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER")
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER")
  }
  return num
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter
  decode(input: BinaryReader | Uint8Array, length?: number): T
  fromJSON(object: any): T
  toJSON(message: T): unknown
  create(base?: DeepPartial<T>): T
  fromPartial(object: DeepPartial<T>): T
}
